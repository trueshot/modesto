<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ModelT Warehouse 3D Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100vh;
            touch-action: none;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 300px;
        }
        #warehouseSelector {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 5px;
            color: white;
        }
        #warehouseSelector select {
            padding: 5px 10px;
            margin: 0 5px;
            border-radius: 3px;
            border: 1px solid #666;
            background: #333;
            color: white;
            cursor: pointer;
        }
        #debug {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
            max-height: 90vh;
            overflow-y: auto;
            max-width: 300px;
        }
        #cameraInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
            min-width: 250px;
            border: 2px solid rgba(255, 200, 50, 0.8);
        }
        #cameraInfo h3 {
            margin: 0 0 10px 0;
            color: rgba(255, 200, 50, 1);
            font-size: 14px;
        }
        #cameraInfo .param {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }
        #cameraInfo .param .label {
            color: rgba(200, 200, 200, 1);
        }
        #cameraInfo .param .value {
            color: rgba(100, 200, 255, 1);
            font-weight: bold;
        }
        #cameraControls {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            max-width: 90%;
            justify-content: center;
        }
        .cameraBtn {
            background: rgba(255, 100, 100, 0.8);
            color: white;
            border: 2px solid transparent;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: background 0.2s, border-color 0.2s;
        }
        .cameraBtn:hover {
            background: rgba(255, 150, 150, 1);
        }
        .cameraBtn:active {
            background: rgba(200, 50, 50, 1);
        }
        .cameraBtn.selected {
            background: rgba(255, 200, 50, 1);
            border-color: rgba(255, 255, 255, 0.9);
            color: black;
        }
        .overviewBtn {
            background: rgba(100, 100, 255, 0.8);
        }
        .overviewBtn:hover {
            background: rgba(150, 150, 255, 1);
        }
        .overviewBtn.selected {
            background: rgba(100, 200, 255, 1);
            border-color: rgba(255, 255, 255, 0.9);
            color: black;
        }
        .viewToggleBtn {
            background: rgba(100, 200, 100, 0.8);
            color: white;
            border: 2px solid transparent;
            padding: 5px 12px;
            margin-left: 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: background 0.2s;
        }
        .viewToggleBtn:hover {
            background: rgba(150, 220, 150, 1);
        }
        .viewToggleBtn:active {
            background: rgba(80, 180, 80, 1);
        }
        #svgContainer {
            display: none;
            width: 100%;
            height: 100vh;
            background: white;
            flex-direction: column;
        }
        #svgContainer.active {
            display: flex;
        }
        #svgControls {
            position: sticky;
            top: 0;
            background: white;
            padding: 10px;
            border-bottom: 2px solid #ccc;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 100;
        }
        .zoomBtn {
            background: rgba(100, 200, 100, 0.8);
            color: white;
            border: 2px solid transparent;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: background 0.2s;
        }
        .zoomBtn:hover {
            background: rgba(150, 220, 150, 1);
        }
        .zoomBtn.active {
            background: rgba(50, 180, 50, 1);
            border-color: rgba(255, 255, 255, 0.9);
        }
        #svgViewerContainer {
            flex: 1;
            overflow: auto;
        }
        #svgViewer {
            display: inline-block;
            padding: 20px;
            transform-origin: top left;
            transition: transform 0.1s;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://unpkg.com/earcut@2.2.4/dist/earcut.min.js"></script>
    <script src="/js/warehouseParser.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="warehouseSelector">
        <label for="warehouse">Warehouse:</label>
        <select id="warehouse" onchange="changeWarehouse(this.value)">
            <option value="">Loading...</option>
        </select>
        <button id="viewToggle" class="viewToggleBtn" onclick="toggleView()">View 2D SVG</button>
    </div>
    <div id="svgContainer">
        <div id="svgControls">
            <button class="viewToggleBtn" onclick="toggleView()">View 3D Model</button>
            <span style="margin-left: 20px; color: #666;">Zoom:</span>
            <button class="zoomBtn active" onclick="setSvgZoom(1)">1x</button>
            <button class="zoomBtn" onclick="setSvgZoom(2)">2x</button>
            <button class="zoomBtn" onclick="setSvgZoom(3)">3x</button>
        </div>
        <div id="svgViewerContainer">
            <div id="svgViewer"></div>
        </div>
    </div>
    <div id="info">
        <strong>ModelT 3D Viewer</strong><br>
        <span id="status">Initializing...</span>
    </div>
    <div id="cameraControls">
        <button class="cameraBtn overviewBtn" onclick="setCameraView('overview', this)">Overview</button>
    </div>
    <div id="debug">
        <strong>Debug Info:</strong><br>
        <div id="debugContent"></div>
    </div>
    <div id="cameraInfo" style="display: none;">
        <h3 id="cameraName">Camera View</h3>
        <div class="param">
            <span class="label">Position (X, Y):</span>
            <span class="value" id="camPos">-</span>
        </div>
        <div class="param">
            <span class="label">Elevation:</span>
            <span class="value" id="camElevation">-</span>
        </div>
        <div class="param">
            <span class="label">Direction:</span>
            <span class="value" id="camDirection">-</span>
        </div>
        <div class="param">
            <span class="label">Tilt:</span>
            <span class="value" id="camTilt">-</span>
        </div>
        <div class="param">
            <span class="label">Viewing Angle:</span>
            <span class="value" id="camViewAngle">-</span>
        </div>
        <div class="param">
            <span class="label">Range:</span>
            <span class="value" id="camRange">-</span>
        </div>
        <hr style="border-color: rgba(255,255,255,0.3); margin: 8px 0;">
        <div class="param">
            <span class="label">Pointing At:</span>
            <span class="value" id="targetSurface">-</span>
        </div>
        <div class="param">
            <span class="label">Target (X, Y):</span>
            <span class="value" id="targetCoords">-</span>
        </div>
        <div class="param">
            <span class="label">Distance:</span>
            <span class="value" id="targetDistance">-</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const statusEl = document.getElementById("status");
        const debugEl = document.getElementById("debugContent");
        const warehouseSelector = document.getElementById("warehouse");

        // Global references
        let currentScene = null;
        let currentCamera = null;
        let arcRotateCamera = null;
        let universalCamera = null;
        let warehouseCameras = [];
        let currentSelectedButton = null;
        let currentCameraData = null;
        let lensDistortionEffect = null;
        let currentWarehouseId = null;
        let currentSvgZoom = 1;
        let currentSvgData = null;
        let ws = null;
        let viewMarker = null;  // Floating marker box in front of camera

        // WebSocket setup
        function initWebSocket() {
            ws = new WebSocket('ws://localhost:8080');

            ws.onopen = () => {
                console.log('WebSocket connected');
                // Register with current warehouse (if one is loaded)
                if (currentWarehouseId) {
                    console.log(`Registering with WebSocket server for warehouse: ${currentWarehouseId}`);
                    ws.send(JSON.stringify({
                        type: 'register',
                        warehouseId: currentWarehouseId
                    }));
                } else {
                    console.log('No warehouse loaded yet, will register after warehouse loads');
                }
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);

                    // Handle test messages from Claude
                    if (data.type === 'test') {
                        console.log('ðŸ”µ TEST MESSAGE FROM CLAUDE:', data.message);
                        console.log('   Full payload:', data);
                    }

                    // Handle reload warehouse command from Claude
                    else if (data.type === 'reload-warehouse') {
                        console.log('ðŸ”„ RELOADING WAREHOUSE:', data.warehouseId);
                        // Camera view will be automatically restored from sessionStorage after reload
                        loadWarehouse(data.warehouseId);
                    }

                    // Handle queries from Claude
                    else if (data.type === 'query') {
                        handleQuery(data);
                    }
                } catch (error) {
                    console.error('WebSocket message error:', error);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected, reconnecting in 3s...');
                setTimeout(initWebSocket, 3000);
            };
        }

        // Handle queries from Claude via WebSocket
        function handleQuery(query) {
            if (query.command === 'get-camera-intersection') {
                const cameraId = query.cameraId;
                const intersection = getCameraIntersection(cameraId);

                // Send response back via WebSocket
                ws.send(JSON.stringify({
                    type: 'query-response',
                    queryId: query.queryId,
                    command: query.command,
                    result: intersection
                }));
            }
            else if (query.command === 'get-current-view') {
                // Return current camera view and what they're pointing at
                const result = {
                    activeCamera: currentScene.activeCamera === universalCamera ? 'camera-view' : 'overview',
                    cameraId: currentCameraData ? currentCameraData.name : null,
                    cameraNumber: currentCameraData ? currentCameraData.number : null,
                    position: universalCamera ? {
                        x: universalCamera.position.x.toFixed(1),
                        y: universalCamera.position.y.toFixed(1),
                        z: universalCamera.position.z.toFixed(1)
                    } : null,
                    target: {
                        surface: document.getElementById('targetSurface').textContent,
                        coords: document.getElementById('targetCoords').textContent,
                        distance: document.getElementById('targetDistance').textContent
                    }
                };

                ws.send(JSON.stringify({
                    type: 'query-response',
                    queryId: query.queryId,
                    command: query.command,
                    result: result
                }));
            }
        }

        // Get camera intersection data using raycasting
        function getCameraIntersection(cameraId) {
            if (!currentScene) {
                return { error: 'No scene loaded' };
            }

            // Find camera in warehouse data
            const camera = warehouseCameras.find(c => c.id === cameraId);
            if (!camera) {
                return { error: `Camera "${cameraId}" not found` };
            }

            // Get slab elevation (default 4)
            const slabElevation = camera.slabElevation || 4;
            const cameraY = slabElevation + (camera.elevation || 12);

            // Create camera position in Babylon coords
            const cameraPos = new BABYLON.Vector3(camera.x, cameraY, -camera.y);

            // Calculate viewing direction from camera orientation
            const directionRad = camera.direction * Math.PI / 180;
            const tiltRad = camera.tilt * Math.PI / 180;

            // Direction vector (accounting for tilt)
            const horizontalDist = Math.cos(tiltRad);
            const verticalDist = -Math.sin(tiltRad); // Negative because tilting down

            const direction = new BABYLON.Vector3(
                horizontalDist * Math.sin(directionRad),
                verticalDist,
                -horizontalDist * Math.cos(directionRad)
            );

            // Create ray from camera position
            const ray = new BABYLON.Ray(cameraPos, direction, camera.range || 50);

            // Perform raycast picking
            const hit = currentScene.pickWithRay(ray, (mesh) => {
                // Only pick walls (segments), doors, slabs, columns (not cameras, lines, etc.)
                return mesh.name && (
                    mesh.name.includes('_seg') ||  // Wall segments like mercury_mercury_perimeter_seg0
                    mesh.name.includes('door') ||
                    mesh.name.includes('slab') ||
                    mesh.name.includes('partition') ||
                    mesh.name.includes('column')  // Columns
                );
            });

            if (hit && hit.hit) {
                return {
                    camera: {
                        id: camera.id,
                        name: camera.name || camera.id,
                        number: camera.number,
                        position: { x: camera.x, y: camera.y, elevation: camera.elevation },
                        direction: camera.direction,
                        tilt: camera.tilt
                    },
                    intersection: {
                        hit: true,
                        objectName: hit.pickedMesh.name,
                        objectType: hit.pickedMesh.name.includes('wall') ? 'wall' :
                                   hit.pickedMesh.name.includes('door') ? 'door' :
                                   hit.pickedMesh.name.includes('slab') ? 'slab' : 'unknown',
                        point: {
                            x: hit.pickedPoint.x,
                            y: hit.pickedPoint.y,
                            z: hit.pickedPoint.z
                        },
                        svgCoords: {
                            x: Math.round(hit.pickedPoint.x * 10) / 10,
                            y: Math.round(-hit.pickedPoint.z * 10) / 10
                        },
                        distance: Math.round(hit.distance * 10) / 10
                    }
                };
            } else {
                return {
                    camera: {
                        id: camera.id,
                        name: camera.name || camera.id,
                        number: camera.number,
                        position: { x: camera.x, y: camera.y, elevation: camera.elevation },
                        direction: camera.direction,
                        tilt: camera.tilt
                    },
                    intersection: {
                        hit: false,
                        message: 'Camera view line does not intersect any objects within range'
                    }
                };
            }
        }

        // Get warehouse ID from query parameter or default to 'lodge'
        function getWarehouseIdFromURL() {
            const params = new URLSearchParams(window.location.search);
            return params.get('warehouse') || 'lodge';
        }

        // Load list of available warehouses
        async function loadWarehouseList() {
            try {
                const response = await fetch('/api/warehouses');
                const data = await response.json();

                if (data.warehouses && data.warehouses.length > 0) {
                    warehouseSelector.innerHTML = '';
                    const selectedId = getWarehouseIdFromURL();

                    data.warehouses.forEach(wh => {
                        const option = document.createElement('option');
                        option.value = wh.id;
                        option.textContent = wh.name || wh.id;
                        if (wh.id === selectedId) {
                            option.selected = true;
                        }
                        warehouseSelector.appendChild(option);
                    });

                    // Load the selected warehouse
                    await loadWarehouse(selectedId);
                }
            } catch (error) {
                statusEl.textContent = `Error loading warehouses: ${error.message}`;
                debugEl.textContent = error.stack;
            }
        }

        // Change warehouse when selector changes
        async function changeWarehouse(warehouseId) {
            if (warehouseId) {
                await loadWarehouse(warehouseId);
            }
        }

        // Load warehouse from API
        async function loadWarehouse(warehouseId) {
            try {
                currentWarehouseId = warehouseId;
                statusEl.textContent = `Loading ${warehouseId}...`;

                // Fetch SVG data via API
                const response = await fetch(`/api/warehouses/${warehouseId}/svg-data`);
                if (!response.ok) {
                    throw new Error(`Failed to load SVG: ${response.statusText}`);
                }

                const data = await response.json();
                const svgText = data.svg;

                // Store SVG data for toggle view
                currentSvgData = svgText;

                statusEl.textContent = "Parsing warehouse data...";

                // Parse SVG
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');

                // Check for ModelT format
                const modelTSchema = svgDoc.getElementById('modelt-schema');
                let warehouseData, isModelT = false;

                if (modelTSchema) {
                    isModelT = true;
                    const modelTParser = new ModelTParser(svgDoc);
                    warehouseData = modelTParser.parse();
                } else {
                    const warehouseParser = new WarehouseParser(svgDoc);
                    warehouseData = warehouseParser.parse();
                }

                // Debug output
                if (isModelT) {
                    const isV2 = warehouseData.slabs && Array.isArray(warehouseData.slabs);

                    if (isV2) {
                        const slabsInfo = warehouseData.slabs.map(slab => `
                            <strong>${slab.id}</strong>: ${slab.name}<br>
                            &nbsp;&nbsp;Walls: ${slab.walls?.length || 0}
                            (${slab.walls?.filter(w => w.type === 'slabPerimeter').length || 0} perimeter,
                            ${slab.walls?.filter(w => w.type === 'perimeter').length || 0} standalone,
                            ${slab.walls?.filter(w => w.type === 'partition').length || 0} partition)<br>
                            &nbsp;&nbsp;Columns: ${slab.columns?.length || 0}<br>
                            &nbsp;&nbsp;Doors: ${slab.doors?.length || 0}<br>
                            &nbsp;&nbsp;Cameras: ${slab.cameras?.length || 0}<br>
                        `).join('');

                        debugEl.innerHTML = `
                            <strong>ModelT v2.0 Format</strong><br>
                            <strong>Facility:</strong> ${warehouseData.name}<br>
                            <strong>Location:</strong> ${warehouseData.location?.city}, ${warehouseData.location?.state}<br>
                            <strong>Slabs:</strong> ${warehouseData.slabs.length}<br>
                            ${slabsInfo}
                        `;
                    } else {
                        debugEl.innerHTML = `
                            <strong>ModelT v1.0 Format</strong><br>
                            <strong>Parsed Components:</strong><br>
                            Slab: ${warehouseData.slab ? 'âœ“' : 'âœ—'}<br>
                            Walls: ${warehouseData.walls ? 'âœ“' : 'âœ—'}<br>
                            Partition Walls: ${warehouseData.partitionWalls?.length || 0}<br>
                            Columns: ${warehouseData.columns?.length || 0}<br>
                            Doors: ${warehouseData.doors?.length || 0}<br>
                            Cameras: ${warehouseData.cameras?.length || 0}<br>
                        `;
                    }
                }

                statusEl.textContent = "Building 3D scene...";

                // Dispose old scene if exists
                if (currentScene) {
                    currentScene.dispose();
                }

                // Create scene
                const scene = createScene(warehouseData, isModelT);

                // Populate camera buttons
                populateCameraButtons(warehouseData, isModelT);

                statusEl.textContent = "Ready!";

                // Register with WebSocket server now that warehouse is loaded
                if (ws && ws.readyState === WebSocket.OPEN && currentWarehouseId) {
                    console.log(`Registering with WebSocket server for warehouse: ${currentWarehouseId}`);
                    ws.send(JSON.stringify({
                        type: 'register',
                        warehouseId: currentWarehouseId
                    }));
                }

                // Restore previous camera view from sessionStorage
                const savedCameraId = sessionStorage.getItem('currentCameraId');
                const savedRotation = sessionStorage.getItem('cameraRotation');
                if (savedCameraId) {
                    console.log(`Restoring camera view: ${savedCameraId}`);
                    // Give the scene a moment to fully initialize
                    setTimeout(() => {
                        const buttons = document.querySelectorAll('.cameraBtn');
                        buttons.forEach(btn => {
                            if (btn.textContent.toLowerCase().includes(savedCameraId.toLowerCase()) ||
                                (savedCameraId === 'overview' && btn.classList.contains('overviewBtn'))) {
                                btn.click();

                                // Restore camera rotation after camera is set
                                if (savedRotation && savedCameraId !== 'overview') {
                                    setTimeout(() => {
                                        try {
                                            const rotation = JSON.parse(savedRotation);
                                            if (universalCamera) {
                                                universalCamera.rotation.x = rotation.x;
                                                universalCamera.rotation.y = rotation.y;
                                                universalCamera.rotation.z = rotation.z;
                                                console.log(`Restored camera rotation:`, rotation);
                                            }
                                        } catch (e) {
                                            console.error('Failed to restore camera rotation:', e);
                                        }
                                    }, 100);
                                }
                            }
                        });
                    }, 100);
                }

            } catch (error) {
                statusEl.textContent = `Error: ${error.message}`;
                debugEl.innerHTML = `<pre style="color: red;">${error.stack}</pre>`;
                console.error(error);
            }
        }

        function createScene(warehouseData, isModelT) {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.8, 0.9, 1.0);

            scene.metadata = {
                isV2: warehouseData.slabs && Array.isArray(warehouseData.slabs),
                warehouseData: warehouseData,
                builder: null
            };

            // Get slab info for camera positioning
            let centerX, centerY, centerZ;
            if (isModelT) {
                const isV2 = warehouseData.slabs && Array.isArray(warehouseData.slabs);
                const corners = isV2 ? warehouseData.slabs[0].corners : warehouseData.slab.corners;
                const xs = corners.map(c => c.x);
                const ys = corners.map(c => c.y);
                const minX = Math.min(...xs);
                const maxX = Math.max(...xs);
                const minY = Math.min(...ys);
                const maxY = Math.max(...ys);
                centerX = (minX + maxX) / 2;
                centerY = 10;
                centerZ = -((minY + maxY) / 2);
            } else {
                const slab = warehouseData.slab;
                centerX = slab.x + slab.width / 2;
                centerY = 10;
                centerZ = -(slab.y + slab.height / 2);
            }

            // ArcRotate Camera
            arcRotateCamera = new BABYLON.ArcRotateCamera(
                "arcCamera",
                -3 * Math.PI / 4,
                Math.PI / 3,
                600,
                new BABYLON.Vector3(centerX, centerY, centerZ),
                scene
            );
            arcRotateCamera.lowerRadiusLimit = 50;
            arcRotateCamera.upperRadiusLimit = 1500;
            arcRotateCamera.lowerBetaLimit = -Math.PI / 2;
            arcRotateCamera.upperBetaLimit = Math.PI;

            // Universal Camera
            universalCamera = new BABYLON.UniversalCamera(
                "fpCamera",
                new BABYLON.Vector3(centerX, centerY, centerZ),
                scene
            );
            universalCamera.speed = 2;
            universalCamera.angularSensibility = 1000;

            // Start with arc rotate camera
            scene.activeCamera = arcRotateCamera;
            arcRotateCamera.attachControl(canvas, true);

            // Store global references
            currentScene = scene;
            currentCamera = arcRotateCamera;

            // Lighting
            const hemiLight = new BABYLON.HemisphericLight(
                "hemiLight",
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            hemiLight.intensity = 0.7;

            const dirLight = new BABYLON.DirectionalLight(
                "dirLight",
                new BABYLON.Vector3(-1, -2, -1),
                scene
            );
            dirLight.intensity = 0.5;

            // Ground plane
            let groundWidth = 800;
            let groundHeight = 800;
            let groundCenterX = 0;
            let groundCenterZ = 0;

            if (isModelT && warehouseData.property && warehouseData.property.boundary) {
                const boundary = warehouseData.property.boundary;
                groundWidth = boundary.width;
                groundHeight = boundary.height;
                groundCenterX = boundary.x + boundary.width / 2;
                groundCenterZ = -(boundary.y + boundary.height / 2);
            }

            const ground = BABYLON.MeshBuilder.CreateGround(
                "ground",
                { width: groundWidth, height: groundHeight },
                scene
            );
            ground.position.x = groundCenterX;
            ground.position.y = 0;
            ground.position.z = groundCenterZ;

            const groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
            groundMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.6, 0.35);
            groundMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMaterial;

            // Build warehouse
            let builder, meshes;
            if (isModelT) {
                builder = new ModelTBuilder(scene, warehouseData);
                meshes = builder.build();
                scene.metadata.builder = builder;
            } else {
                builder = new WarehouseBuilder(scene, warehouseData);
                meshes = builder.build();
            }

            // Add coordinate axes
            const axisSize = 100;

            const axisX = BABYLON.MeshBuilder.CreateLines("axisX", {
                points: [
                    new BABYLON.Vector3(0, 0, 0),
                    new BABYLON.Vector3(axisSize, 0, 0)
                ]
            }, scene);
            axisX.color = new BABYLON.Color3(1, 0, 0);

            const axisY = BABYLON.MeshBuilder.CreateLines("axisY", {
                points: [
                    new BABYLON.Vector3(0, 0, 0),
                    new BABYLON.Vector3(0, axisSize, 0)
                ]
            }, scene);
            axisY.color = new BABYLON.Color3(0, 1, 0);

            const axisZ = BABYLON.MeshBuilder.CreateLines("axisZ", {
                points: [
                    new BABYLON.Vector3(0, 0, 0),
                    new BABYLON.Vector3(0, 0, axisSize)
                ]
            }, scene);
            axisZ.color = new BABYLON.Color3(0, 0, 1);

            return scene;
        }

        function populateCameraButtons(warehouseData, isModelT) {
            const controlsDiv = document.getElementById("cameraControls");

            // Clear existing buttons (except overview)
            const buttons = controlsDiv.querySelectorAll('.cameraBtn:not(.overviewBtn)');
            buttons.forEach(btn => btn.remove());

            // Get cameras from warehouse data
            warehouseCameras = [];
            if (isModelT) {
                const isV2 = warehouseData.slabs && Array.isArray(warehouseData.slabs);
                if (isV2) {
                    warehouseData.slabs.forEach(slab => {
                        if (slab.cameras && slab.cameras.length > 0) {
                            warehouseCameras.push(...slab.cameras.map(cam => ({
                                ...cam,
                                slabElevation: slab.elevation || 4
                            })));
                        }
                    });
                } else {
                    if (warehouseData.cameras) {
                        warehouseCameras.push(...warehouseData.cameras.map(cam => ({
                            ...cam,
                            slabElevation: 4
                        })));
                    }
                }
            }

            // Add button for each camera
            warehouseCameras.forEach(cam => {
                const btn = document.createElement('button');
                btn.className = 'cameraBtn';
                btn.textContent = `${cam.name || cam.id} (#${cam.number || '?'})`;
                btn.onclick = (e) => setCameraView(cam.id, e.target);
                controlsDiv.appendChild(btn);
            });

            // Select overview button by default
            const overviewBtn = document.querySelector('.overviewBtn');
            if (overviewBtn) {
                overviewBtn.classList.add('selected');
                currentSelectedButton = overviewBtn;
            }
        }

        function updateCameraInfoPanel(cam) {
            document.getElementById('cameraInfo').style.display = 'block';
            document.getElementById('cameraName').textContent = `${cam.name || cam.id} (#${cam.number || '?'})`;

            currentCameraData = {
                name: cam.name || cam.id,
                number: cam.number || '?',
                initialX: cam.x,
                initialY: cam.y,
                slabElevation: cam.slabElevation,
                initialElevation: cam.elevation || 12,
                viewingAngle: cam.viewingAngle || 90,
                range: cam.range || 50
            };
        }

        let lastHitMeshName = null;

        function updateViewMarker() {
            if (!viewMarker || !universalCamera) return;
            if (currentScene.activeCamera !== universalCamera) return;

            // Raycast from camera to find wall intersection
            const direction = universalCamera.getDirection(BABYLON.Vector3.Forward());
            const ray = new BABYLON.Ray(universalCamera.position, direction, 200);

            const hit = currentScene.pickWithRay(ray, (mesh) => {
                // Only pick walls (segments), doors, slabs, columns
                return mesh.name && (
                    mesh.name.includes('_seg') ||  // Wall segments
                    mesh.name.includes('door') ||
                    mesh.name.includes('slab') ||
                    mesh.name.includes('partition') ||
                    mesh.name.includes('column')  // Columns
                );
            });

            if (hit && hit.hit) {
                // Stick to the wall at intersection point
                viewMarker.position = hit.pickedPoint;
                viewMarker.isVisible = true;

                // Update info panel in real-time
                const svgX = hit.pickedPoint.x.toFixed(1);
                const svgY = (-hit.pickedPoint.z).toFixed(1);
                const distance = hit.distance.toFixed(1);

                document.getElementById('targetSurface').textContent = hit.pickedMesh.name;
                document.getElementById('targetCoords').textContent = `(${svgX}, ${svgY})`;
                document.getElementById('targetDistance').textContent = `${distance}ft`;

                // Track last hit for change detection
                lastHitMeshName = hit.pickedMesh.name;
            } else {
                // No hit - float 15 feet in front
                const distance = 15;
                viewMarker.position = universalCamera.position.add(direction.scale(distance));
                viewMarker.isVisible = true;

                // Update info panel
                document.getElementById('targetSurface').textContent = 'Open space';
                document.getElementById('targetCoords').textContent = '-';
                document.getElementById('targetDistance').textContent = '-';

                lastHitMeshName = null;
            }
        }

        function updateCameraInfoRealtime() {
            if (!universalCamera || !currentCameraData) return;
            if (currentScene.activeCamera !== universalCamera) return;

            const pos = universalCamera.position;
            const svgX = pos.x;
            const svgY = -pos.z;
            const elevation = pos.y - (currentCameraData.slabElevation || 4);

            let directionDeg = -(universalCamera.rotation.y * 180 / Math.PI);
            while (directionDeg < 0) directionDeg += 360;
            while (directionDeg >= 360) directionDeg -= 360;

            let tiltDeg = universalCamera.rotation.x * 180 / Math.PI;

            document.getElementById('camPos').textContent = `(${svgX.toFixed(1)}, ${svgY.toFixed(1)})`;
            document.getElementById('camElevation').textContent = `${elevation.toFixed(1)}ft above slab`;

            const compassName = getCompassName(directionDeg);
            document.getElementById('camDirection').textContent = `${compassName} (${directionDeg.toFixed(0)}Â°)`;
            document.getElementById('camTilt').textContent = `${tiltDeg.toFixed(1)}Â° down`;
            document.getElementById('camViewAngle').textContent = `${currentCameraData.viewingAngle}Â°`;
            document.getElementById('camRange').textContent = `${currentCameraData.range}ft`;
        }

        function getCompassName(deg) {
            if (deg >= 337.5 || deg < 22.5) return 'North';
            if (deg >= 22.5 && deg < 67.5) return 'NE';
            if (deg >= 67.5 && deg < 112.5) return 'East';
            if (deg >= 112.5 && deg < 157.5) return 'SE';
            if (deg >= 157.5 && deg < 202.5) return 'South';
            if (deg >= 202.5 && deg < 247.5) return 'SW';
            if (deg >= 247.5 && deg < 292.5) return 'West';
            if (deg >= 292.5 && deg < 337.5) return 'NW';
            return '';
        }

        function setCameraView(cameraId, buttonElement) {
            if (!currentScene) {
                return;
            }

            // Store current camera in sessionStorage
            sessionStorage.setItem('currentCameraId', cameraId);

            if (currentSelectedButton) {
                currentSelectedButton.classList.remove('selected');
            }
            if (buttonElement) {
                buttonElement.classList.add('selected');
                currentSelectedButton = buttonElement;
            }

            if (cameraId === 'overview') {
                document.getElementById('cameraInfo').style.display = 'none';

                // Remove view marker when switching to overview
                if (viewMarker) {
                    viewMarker.dispose();
                    viewMarker = null;
                }

                if (currentScene.activeCamera !== arcRotateCamera) {
                    currentCamera.detachControl();
                    currentScene.activeCamera = arcRotateCamera;
                    arcRotateCamera.attachControl(canvas, true);
                    currentCamera = arcRotateCamera;
                }

                const isV2 = currentScene.metadata && currentScene.metadata.isV2;
                const warehouseData = currentScene.metadata && currentScene.metadata.warehouseData;

                if (warehouseData) {
                    const corners = isV2 ? warehouseData.slabs[0].corners : warehouseData.slab.corners;
                    const xs = corners.map(c => c.x);
                    const ys = corners.map(c => c.y);
                    const centerX = (Math.min(...xs) + Math.max(...xs)) / 2;
                    const centerY = 10;
                    const centerZ = -((Math.min(...ys) + Math.max(...ys)) / 2);

                    arcRotateCamera.setTarget(new BABYLON.Vector3(centerX, centerY, centerZ));
                }

                arcRotateCamera.alpha = -3 * Math.PI / 4;
                arcRotateCamera.beta = Math.PI / 3;
                arcRotateCamera.radius = 600;
                return;
            }

            const cam = warehouseCameras.find(c => c.id === cameraId);
            if (!cam) {
                return;
            }

            updateCameraInfoPanel(cam);

            if (currentScene.activeCamera !== universalCamera) {
                currentCamera.detachControl();
                currentScene.activeCamera = universalCamera;
                universalCamera.attachControl(canvas, true);
                currentCamera = universalCamera;
            }

            const camPosX = cam.x;
            const camPosY = cam.slabElevation + (cam.elevation || 12);
            const camPosZ = -cam.y;

            universalCamera.position = new BABYLON.Vector3(camPosX, camPosY, camPosZ);

            const directionRad = cam.direction * Math.PI / 180;
            universalCamera.rotation.y = -directionRad;

            const tiltRad = cam.tilt * Math.PI / 180;
            universalCamera.rotation.x = tiltRad;

            // Create floating view marker sphere
            if (!viewMarker) {
                viewMarker = BABYLON.MeshBuilder.CreateSphere(
                    'viewMarker',
                    { diameter: 0.8 },
                    currentScene
                );
                const markerMat = new BABYLON.StandardMaterial('viewMarkerMat', currentScene);
                markerMat.diffuseColor = new BABYLON.Color3(0, 1, 0); // Bright green
                markerMat.emissiveColor = new BABYLON.Color3(0, 0.5, 0); // Glowing green
                viewMarker.material = markerMat;

                // Make sphere clickable to mark position
                viewMarker.actionManager = new BABYLON.ActionManager(currentScene);
                viewMarker.actionManager.registerAction(
                    new BABYLON.ExecuteCodeAction(
                        BABYLON.ActionManager.OnPickTrigger,
                        function() {
                            // Get current target info from info panel
                            const targetSurface = document.getElementById('targetSurface').textContent;
                            const targetCoords = document.getElementById('targetCoords').textContent;
                            const targetDistance = document.getElementById('targetDistance').textContent;

                            // Parse coordinates
                            const coordMatch = targetCoords.match(/\(([^,]+),\s*([^)]+)\)/);
                            if (coordMatch) {
                                const x = parseFloat(coordMatch[1]);
                                const y = parseFloat(coordMatch[2]);

                                // Get current camera rotation for restoration after reload
                                const cameraRotation = universalCamera ? {
                                    x: universalCamera.rotation.x,
                                    y: universalCamera.rotation.y,
                                    z: universalCamera.rotation.z
                                } : null;

                                // Save camera orientation to sessionStorage
                                if (cameraRotation && currentCameraData) {
                                    sessionStorage.setItem('cameraRotation', JSON.stringify(cameraRotation));
                                    console.log(`Saved camera rotation:`, cameraRotation);
                                }

                                // Send marked position to server via WebSocket
                                if (ws && ws.readyState === WebSocket.OPEN) {
                                    ws.send(JSON.stringify({
                                        type: 'mark-position',
                                        warehouseId: currentWarehouseId,
                                        camera: {
                                            id: currentCameraData ? currentCameraData.id : null,
                                            name: currentCameraData ? currentCameraData.name : null,
                                            number: currentCameraData ? currentCameraData.number : null,
                                            rotation: cameraRotation
                                        },
                                        position: {
                                            x: x,
                                            y: y,
                                            surface: targetSurface,
                                            distance: targetDistance
                                        },
                                        timestamp: Date.now()
                                    }));
                                    console.log(`Marked position: (${x}, ${y}) on ${targetSurface} from camera ${currentCameraData ? currentCameraData.name : 'unknown'}`);

                                    // Visual feedback - flash the sphere
                                    markerMat.emissiveColor = new BABYLON.Color3(1, 1, 0); // Yellow flash
                                    setTimeout(() => {
                                        markerMat.emissiveColor = new BABYLON.Color3(0, 0.5, 0); // Back to green
                                    }, 200);
                                }
                            }
                        }
                    )
                );
            }

            const viewingAngleDeg = cam.viewingAngle || 90;
            const aspectRatio = engine.getRenderWidth() / engine.getRenderHeight();

            const hFovRad = viewingAngleDeg * Math.PI / 180;
            const vFovRad = 2 * Math.atan(Math.tan(hFovRad / 2) / aspectRatio);

            universalCamera.fov = vFovRad;
        }

        function setSvgZoom(zoomLevel) {
            currentSvgZoom = zoomLevel;
            const svgViewer = document.getElementById("svgViewer");

            // Apply zoom transform
            svgViewer.style.transform = `scale(${zoomLevel})`;

            // Update button states
            const zoomBtns = document.querySelectorAll('.zoomBtn');
            zoomBtns.forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent === `${zoomLevel}x`) {
                    btn.classList.add('active');
                }
            });
        }

        function toggleView() {
            const renderCanvas = document.getElementById("renderCanvas");
            const svgContainer = document.getElementById("svgContainer");
            const viewToggle = document.getElementById("viewToggle");

            if (renderCanvas.style.display !== "none") {
                // Switch to SVG view
                renderCanvas.style.display = "none";
                svgContainer.classList.add("active");
                viewToggle.textContent = "View 3D Model";

                // Reset zoom to 1x when switching to SVG view
                setSvgZoom(1);

                // Load and display SVG
                if (currentWarehouseId && currentSvgData) {
                    displaySvg(currentSvgData);
                }
            } else {
                // Switch to 3D view
                renderCanvas.style.display = "block";
                svgContainer.classList.remove("active");
                viewToggle.textContent = "View 2D SVG";

                // Resume rendering
                if (currentScene && engine) {
                    engine.runRenderLoop(() => {
                        currentScene.render();
                        updateCameraInfoRealtime();
                    });
                }
            }
        }

        function displaySvg(svgData) {
            const svgViewer = document.getElementById("svgViewer");
            svgViewer.innerHTML = svgData;

            // Apply SVG styles and current zoom level
            const svg = svgViewer.querySelector("svg");
            if (svg) {
                svg.style.display = "block";
                svg.style.border = "1px solid #999";
            }

            // Apply current zoom level
            setSvgZoom(currentSvgZoom);
        }

        // Initialize
        async function init() {
            console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
            console.log('â•‘  ModelT Viewer v2.1 - 2025-01-24 15:45 â•‘');
            console.log('â•‘  Camera raycasting + logging enabled   â•‘');
            console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

            try {
                // Initialize WebSocket connection
                initWebSocket();

                await loadWarehouseList();

                if (currentScene) {
                    engine.runRenderLoop(() => {
                        currentScene.render();
                        updateCameraInfoRealtime();
                        updateViewMarker();
                    });
                }
            } catch (error) {
                statusEl.textContent = `Initialization error: ${error.message}`;
                console.error(error);
            }
        }

        window.addEventListener("resize", () => {
            engine.resize();
        });

        // Start initialization
        init();
    </script>
</body>
</html>
